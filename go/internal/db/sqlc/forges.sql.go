// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: forges.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkReadAccess = `-- name: CheckReadAccess :one
SELECT EXISTS (
    SELECT 1 FROM forges f
    WHERE (f.id = $2 AND f.owner_id = $1)
       OR EXISTS (
            SELECT 1 FROM forge_access
            WHERE forge_id = $2 AND user_id = $1
       )
) AS exists
`

type CheckReadAccessParams struct {
	OwnerID uuid.UUID
	ID      string
}

func (q *Queries) CheckReadAccess(ctx context.Context, arg CheckReadAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkReadAccess, arg.OwnerID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkWriteAccess = `-- name: CheckWriteAccess :one
SELECT EXISTS (
    SELECT 1 FROM forges f
    WHERE (f.id = $2 AND f.owner_id = $1)
       OR EXISTS (
            SELECT 1 FROM forge_access
            WHERE forge_id = $2 AND user_id = $1 AND access_role = 'admin'
       )
) AS exists
`

type CheckWriteAccessParams struct {
	OwnerID uuid.UUID
	ID      string
}

func (q *Queries) CheckWriteAccess(ctx context.Context, arg CheckWriteAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkWriteAccess, arg.OwnerID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteForge = `-- name: DeleteForge :exec
DELETE FROM forges WHERE id = $2 AND owner_id = $1
`

type DeleteForgeParams struct {
	OwnerID uuid.UUID
	ID      string
}

func (q *Queries) DeleteForge(ctx context.Context, arg DeleteForgeParams) error {
	_, err := q.db.Exec(ctx, deleteForge, arg.OwnerID, arg.ID)
	return err
}

const deleteForgeAccess = `-- name: DeleteForgeAccess :exec
DELETE FROM forge_access
WHERE forge_id = $2 AND user_id = $1
`

type DeleteForgeAccessParams struct {
	UserID  uuid.UUID
	ForgeID string
}

func (q *Queries) DeleteForgeAccess(ctx context.Context, arg DeleteForgeAccessParams) error {
	_, err := q.db.Exec(ctx, deleteForgeAccess, arg.UserID, arg.ForgeID)
	return err
}

const getForgeAndCheckReadAccess = `-- name: GetForgeAndCheckReadAccess :one
SELECT f.id, f.title, f.description FROM forges f
WHERE f.id = $2 AND (
    f.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = f.id AND fa.user_id = $1
    )
)
`

type GetForgeAndCheckReadAccessParams struct {
	OwnerID uuid.UUID
	ID      string
}

type GetForgeAndCheckReadAccessRow struct {
	ID          string
	Title       string
	Description *string
}

func (q *Queries) GetForgeAndCheckReadAccess(ctx context.Context, arg GetForgeAndCheckReadAccessParams) (GetForgeAndCheckReadAccessRow, error) {
	row := q.db.QueryRow(ctx, getForgeAndCheckReadAccess, arg.OwnerID, arg.ID)
	var i GetForgeAndCheckReadAccessRow
	err := row.Scan(&i.ID, &i.Title, &i.Description)
	return i, err
}

const getForgesAndCheckReadAccess = `-- name: GetForgesAndCheckReadAccess :many
SELECT f.id, f.title, f.description FROM forges f
WHERE f.owner_id = $1
OR EXISTS (
    SELECT 1 FROM forge_access fa
    WHERE fa.forge_id = f.id AND fa.user_id = $1
)
ORDER BY f.updated_at DESC
`

type GetForgesAndCheckReadAccessRow struct {
	ID          string
	Title       string
	Description *string
}

func (q *Queries) GetForgesAndCheckReadAccess(ctx context.Context, ownerID uuid.UUID) ([]GetForgesAndCheckReadAccessRow, error) {
	rows, err := q.db.Query(ctx, getForgesAndCheckReadAccess, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetForgesAndCheckReadAccessRow
	for rows.Next() {
		var i GetForgesAndCheckReadAccessRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertForge = `-- name: InsertForge :exec
INSERT INTO forges (id, title, description, owner_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT DO NOTHING
`

type InsertForgeParams struct {
	ID          string
	Title       string
	Description *string
	OwnerID     uuid.UUID
}

func (q *Queries) InsertForge(ctx context.Context, arg InsertForgeParams) error {
	_, err := q.db.Exec(ctx, insertForge,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.OwnerID,
	)
	return err
}

const listForgeAccess = `-- name: ListForgeAccess :many
SELECT fa.id, fa.forge_id, fa.user_id, fa.access_role, fa.added_by, fa.created_at, fa.updated_at, fa.revoked_at, u.name as user_name, u.email as user_email
FROM forge_access fa
JOIN users u ON fa.user_id = u.id
WHERE fa.forge_id = $1
ORDER BY fa.updated_at DESC
`

type ListForgeAccessRow struct {
	ID         uuid.UUID
	ForgeID    string
	UserID     uuid.UUID
	AccessRole AccessRole
	AddedBy    uuid.UUID
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
	RevokedAt  pgtype.Timestamptz
	UserName   *string
	UserEmail  string
}

func (q *Queries) ListForgeAccess(ctx context.Context, forgeID string) ([]ListForgeAccessRow, error) {
	rows, err := q.db.Query(ctx, listForgeAccess, forgeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListForgeAccessRow
	for rows.Next() {
		var i ListForgeAccessRow
		if err := rows.Scan(
			&i.ID,
			&i.ForgeID,
			&i.UserID,
			&i.AccessRole,
			&i.AddedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RevokedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateForgeAndCheckWriteAccess = `-- name: UpdateForgeAndCheckWriteAccess :exec
UPDATE forges f
SET
    title = COALESCE($3, f.title),
    description = COALESCE($4, f.description)
WHERE f.id = $2 AND (
    f.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = $2 AND fa.user_id = $1 AND fa.access_role = 'admin'
    )
)
`

type UpdateForgeAndCheckWriteAccessParams struct {
	OwnerID     uuid.UUID
	ID          string
	Title       *string
	Description *string
}

func (q *Queries) UpdateForgeAndCheckWriteAccess(ctx context.Context, arg UpdateForgeAndCheckWriteAccessParams) error {
	_, err := q.db.Exec(ctx, updateForgeAndCheckWriteAccess,
		arg.OwnerID,
		arg.ID,
		arg.Title,
		arg.Description,
	)
	return err
}

const upsertForgeAccess = `-- name: UpsertForgeAccess :exec
INSERT INTO forge_access (id, forge_id, user_id, access_role, added_by)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (forge_id, user_id) DO UPDATE
SET access_role = $4, added_by = $5, updated_at = NOW()
`

type UpsertForgeAccessParams struct {
	ID         uuid.UUID
	ForgeID    string
	UserID     uuid.UUID
	AccessRole AccessRole
	AddedBy    uuid.UUID
}

func (q *Queries) UpsertForgeAccess(ctx context.Context, arg UpsertForgeAccessParams) error {
	_, err := q.db.Exec(ctx, upsertForgeAccess,
		arg.ID,
		arg.ForgeID,
		arg.UserID,
		arg.AccessRole,
		arg.AddedBy,
	)
	return err
}
