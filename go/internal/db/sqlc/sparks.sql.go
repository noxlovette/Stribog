// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sparks.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteSparkAndCheckAdminAccess = `-- name: DeleteSparkAndCheckAdminAccess :exec
DELETE FROM sparks s
WHERE s.id = $2 AND (
    s.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forges f
        WHERE f.id = s.forge_id AND f.owner_id = $1
    )
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = s.forge_id
        AND fa.user_id = $1
        AND fa.access_role = 'admin'
    )
)
`

type DeleteSparkAndCheckAdminAccessParams struct {
	OwnerID uuid.UUID
	ID      string
}

func (q *Queries) DeleteSparkAndCheckAdminAccess(ctx context.Context, arg DeleteSparkAndCheckAdminAccessParams) error {
	_, err := q.db.Exec(ctx, deleteSparkAndCheckAdminAccess, arg.OwnerID, arg.ID)
	return err
}

const deleteSparkTags = `-- name: DeleteSparkTags :exec
DELETE FROM spark_tags WHERE spark_id = $1
`

func (q *Queries) DeleteSparkTags(ctx context.Context, sparkID string) error {
	_, err := q.db.Exec(ctx, deleteSparkTags, sparkID)
	return err
}

const getSparkAndCheckReadAccess = `-- name: GetSparkAndCheckReadAccess :one
SELECT
  s.id, s.title, s.markdown, s.slug, s.updated_at,
  COALESCE(ARRAY_AGG(st.tag) FILTER (WHERE st.tag IS NOT NULL), '{}')::TEXT[] AS tags
FROM sparks s
JOIN forges f ON s.forge_id = f.id
LEFT JOIN spark_tags st ON st.spark_id = s.id
WHERE s.id = $2 AND (
  s.owner_id = $1
  OR f.owner_id = $1
  OR EXISTS (
    SELECT 1 FROM forge_access fa
    WHERE fa.forge_id = s.forge_id AND fa.user_id = $1
  )
)
GROUP BY s.id, s.title, s.markdown, s.slug
`

type GetSparkAndCheckReadAccessParams struct {
	OwnerID uuid.UUID
	ID      string
}

type GetSparkAndCheckReadAccessRow struct {
	ID        string
	Title     string
	Markdown  string
	Slug      string
	UpdatedAt time.Time
	Tags      []string
}

func (q *Queries) GetSparkAndCheckReadAccess(ctx context.Context, arg GetSparkAndCheckReadAccessParams) (GetSparkAndCheckReadAccessRow, error) {
	row := q.db.QueryRow(ctx, getSparkAndCheckReadAccess, arg.OwnerID, arg.ID)
	var i GetSparkAndCheckReadAccessRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Markdown,
		&i.Slug,
		&i.UpdatedAt,
		&i.Tags,
	)
	return i, err
}

const getSparksByForgeIDAndCheckReadAccess = `-- name: GetSparksByForgeIDAndCheckReadAccess :many
SELECT
  s.id, s.title, s.markdown, s.slug, s.updated_at,
  COALESCE(ARRAY_AGG(st.tag) FILTER (WHERE st.tag IS NOT NULL), '{}')::TEXT[] AS tags
FROM sparks s
JOIN forges f ON s.forge_id = f.id
LEFT JOIN spark_tags st ON st.spark_id = s.id
WHERE s.forge_id = $2 AND (
  s.owner_id = $1
  OR f.owner_id = $1
  OR EXISTS (
    SELECT 1 FROM forge_access fa
    WHERE fa.forge_id = s.forge_id AND fa.user_id = $1
  )
)
GROUP BY s.id, s.title, s.markdown, s.slug
ORDER BY s.updated_at DESC
`

type GetSparksByForgeIDAndCheckReadAccessParams struct {
	OwnerID uuid.UUID
	ForgeID string
}

type GetSparksByForgeIDAndCheckReadAccessRow struct {
	ID        string
	Title     string
	Markdown  string
	Slug      string
	UpdatedAt time.Time
	Tags      []string
}

func (q *Queries) GetSparksByForgeIDAndCheckReadAccess(ctx context.Context, arg GetSparksByForgeIDAndCheckReadAccessParams) ([]GetSparksByForgeIDAndCheckReadAccessRow, error) {
	rows, err := q.db.Query(ctx, getSparksByForgeIDAndCheckReadAccess, arg.OwnerID, arg.ForgeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSparksByForgeIDAndCheckReadAccessRow
	for rows.Next() {
		var i GetSparksByForgeIDAndCheckReadAccessRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Markdown,
			&i.Slug,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForSpark = `-- name: GetTagsForSpark :many
SELECT tag FROM spark_tags WHERE spark_id = $1
`

func (q *Queries) GetTagsForSpark(ctx context.Context, sparkID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getTagsForSpark, sparkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSpark = `-- name: InsertSpark :exec
INSERT INTO sparks (id, forge_id, owner_id, slug)
VALUES ($1, $2, $3, $4)
`

type InsertSparkParams struct {
	ID      string
	ForgeID string
	OwnerID uuid.UUID
	Slug    string
}

func (q *Queries) InsertSpark(ctx context.Context, arg InsertSparkParams) error {
	_, err := q.db.Exec(ctx, insertSpark,
		arg.ID,
		arg.ForgeID,
		arg.OwnerID,
		arg.Slug,
	)
	return err
}

const insertSparkTag = `-- name: InsertSparkTag :exec
INSERT INTO spark_tags (spark_id, tag) VALUES ($1, $2)
`

type InsertSparkTagParams struct {
	SparkID string
	Tag     string
}

func (q *Queries) InsertSparkTag(ctx context.Context, arg InsertSparkTagParams) error {
	_, err := q.db.Exec(ctx, insertSparkTag, arg.SparkID, arg.Tag)
	return err
}

const updateSparkAndCheckWriteAccess = `-- name: UpdateSparkAndCheckWriteAccess :exec
UPDATE sparks s
SET
    title = COALESCE($3, s.title),
    markdown = COALESCE($4, s.markdown),
    slug = COALESCE($5, s.slug)
WHERE s.id = $2 AND (
    s.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forges f
        WHERE f.id = s.forge_id AND f.owner_id = $1
    )
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = s.forge_id
        AND fa.user_id = $1
        AND fa.access_role IN ('admin', 'editor')
    )
)
`

type UpdateSparkAndCheckWriteAccessParams struct {
	OwnerID  uuid.UUID
	ID       string
	Title    *string
	Markdown *string
	Slug     *string
}

func (q *Queries) UpdateSparkAndCheckWriteAccess(ctx context.Context, arg UpdateSparkAndCheckWriteAccessParams) error {
	_, err := q.db.Exec(ctx, updateSparkAndCheckWriteAccess,
		arg.OwnerID,
		arg.ID,
		arg.Title,
		arg.Markdown,
		arg.Slug,
	)
	return err
}
