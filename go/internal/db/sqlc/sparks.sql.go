// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sparks.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const deleteSparkAndCheckAdminAccess = `-- name: DeleteSparkAndCheckAdminAccess :exec
DELETE FROM sparks s
WHERE s.id = $2 AND (
    s.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forges f
        WHERE f.id = s.forge_id AND f.owner_id = $1
    )
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = s.forge_id
        AND fa.user_id = $1
        AND fa.access_role = 'admin'
    )
)
`

type DeleteSparkAndCheckAdminAccessParams struct {
	OwnerID uuid.UUID
	ID      string
}

func (q *Queries) DeleteSparkAndCheckAdminAccess(ctx context.Context, arg DeleteSparkAndCheckAdminAccessParams) error {
	_, err := q.db.Exec(ctx, deleteSparkAndCheckAdminAccess, arg.OwnerID, arg.ID)
	return err
}

const getSparkAndCheckReadAccess = `-- name: GetSparkAndCheckReadAccess :one
SELECT s.id, s.title, s.markdown FROM sparks s
JOIN forges f ON s.forge_id = f.id
WHERE s.id = $2 AND (
    s.owner_id = $1
    OR f.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = s.forge_id AND fa.user_id = $1
    )
)
`

type GetSparkAndCheckReadAccessParams struct {
	OwnerID uuid.UUID
	ID      string
}

type GetSparkAndCheckReadAccessRow struct {
	ID       string
	Title    string
	Markdown string
}

func (q *Queries) GetSparkAndCheckReadAccess(ctx context.Context, arg GetSparkAndCheckReadAccessParams) (GetSparkAndCheckReadAccessRow, error) {
	row := q.db.QueryRow(ctx, getSparkAndCheckReadAccess, arg.OwnerID, arg.ID)
	var i GetSparkAndCheckReadAccessRow
	err := row.Scan(&i.ID, &i.Title, &i.Markdown)
	return i, err
}

const getSparksAndCheckReadAccess = `-- name: GetSparksAndCheckReadAccess :many
SELECT s.id, s.title, s.markdown FROM sparks s
JOIN forges f ON s.forge_id = f.id
WHERE
    s.owner_id = $1
    OR f.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = s.forge_id AND fa.user_id = $1
        )
ORDER BY f.updated_at DESC
`

type GetSparksAndCheckReadAccessRow struct {
	ID       string
	Title    string
	Markdown string
}

func (q *Queries) GetSparksAndCheckReadAccess(ctx context.Context, ownerID uuid.UUID) ([]GetSparksAndCheckReadAccessRow, error) {
	rows, err := q.db.Query(ctx, getSparksAndCheckReadAccess, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSparksAndCheckReadAccessRow
	for rows.Next() {
		var i GetSparksAndCheckReadAccessRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Markdown); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSparksByForgeIDAndCheckReadAccess = `-- name: GetSparksByForgeIDAndCheckReadAccess :many
SELECT s.id, s.title, s.markdown FROM sparks s
JOIN forges f ON s.forge_id = f.id
WHERE
    s.forge_id = $2 AND (
    s.owner_id = $1
    OR f.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = s.forge_id AND fa.user_id = $1
        )
        )
ORDER BY f.updated_at DESC
`

type GetSparksByForgeIDAndCheckReadAccessParams struct {
	OwnerID uuid.UUID
	ForgeID string
}

type GetSparksByForgeIDAndCheckReadAccessRow struct {
	ID       string
	Title    string
	Markdown string
}

func (q *Queries) GetSparksByForgeIDAndCheckReadAccess(ctx context.Context, arg GetSparksByForgeIDAndCheckReadAccessParams) ([]GetSparksByForgeIDAndCheckReadAccessRow, error) {
	rows, err := q.db.Query(ctx, getSparksByForgeIDAndCheckReadAccess, arg.OwnerID, arg.ForgeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSparksByForgeIDAndCheckReadAccessRow
	for rows.Next() {
		var i GetSparksByForgeIDAndCheckReadAccessRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Markdown); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSpark = `-- name: InsertSpark :exec
INSERT INTO sparks (id, title, markdown, forge_id, owner_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT DO NOTHING
`

type InsertSparkParams struct {
	ID       string
	Title    string
	Markdown string
	ForgeID  string
	OwnerID  uuid.UUID
}

func (q *Queries) InsertSpark(ctx context.Context, arg InsertSparkParams) error {
	_, err := q.db.Exec(ctx, insertSpark,
		arg.ID,
		arg.Title,
		arg.Markdown,
		arg.ForgeID,
		arg.OwnerID,
	)
	return err
}

const updateSparkAndCheckWriteAccess = `-- name: UpdateSparkAndCheckWriteAccess :exec
UPDATE sparks s
SET
    title = COALESCE($3, s.title),
    markdown = COALESCE($4, s.markdown)
WHERE s.id = $2 AND (
    s.owner_id = $1
    OR EXISTS (
        SELECT 1 FROM forges f
        WHERE f.id = s.forge_id AND f.owner_id = $1
    )
    OR EXISTS (
        SELECT 1 FROM forge_access fa
        WHERE fa.forge_id = s.forge_id
        AND fa.user_id = $1
        AND fa.access_role IN ('admin', 'editor')
    )
)
`

type UpdateSparkAndCheckWriteAccessParams struct {
	OwnerID  uuid.UUID
	ID       string
	Title    *string
	Markdown *string
}

func (q *Queries) UpdateSparkAndCheckWriteAccess(ctx context.Context, arg UpdateSparkAndCheckWriteAccessParams) error {
	_, err := q.db.Exec(ctx, updateSparkAndCheckWriteAccess,
		arg.OwnerID,
		arg.ID,
		arg.Title,
		arg.Markdown,
	)
	return err
}
